#  Java编程思想

## 对象导论

> **“ 我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是以为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来·······除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。“** 
>
> 							——Benjamin Lee Whorf (1897~1941)

### 1.1 抽象过程

	所有编程语言都是提供抽象机制

**1. 万物皆对象。**

**2. 程序是对象的集合，它们通过发送消息来告知彼此所要做的。**

**3. 每个对象都有自己的由其他对象所构成的存储**

**4. 每个对象都有其类型**

**5. 某个特定类型的所有对象都可以接收同样的消息**



## 一切都是对象

### 2.1 用引用操纵对象

> 每一种编程语言都有自己的操作内存中元素的方式。
>
> 创建一个String引用：String s;
>
> 但是这里所创建的只是引用，并不是对象。如果此时向s发送一个消息，就会返回一个运行时错误，这是因为此时s实际上没有与任何事物相关联。因此一种安全的做法是：String s = ”asdf“;

### 2.2 必须由你创建所有对象

> 一旦创建了对象，就希望它能与一个新的对象关联。通过**new**操作符来实现这一目的。

**1. 寄存器**

	最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。寄存器数量有限，可根据需求进行分配，不能直接控制，不能在程序中感觉到寄存器存在的任何迹象。

**2. 堆栈**

	仅次于寄存器，位于RAM（随机访问存储器），通过堆栈指针可以从处理器那里获得直接支持。堆栈指针向向下移动：分配新的内存，指针向上移动：释放内存。这是一中快速分配存储的方法。
	
	Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动指针。这样限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。

**3.堆**

	一种通用的内存池（也位于RAM区）用于存放所有Java对象。
	
	堆比同于堆栈的好出是：编译器不需要知道存储的数据在堆里存活了多长时间。因此在堆里分配存储有很大的灵活性。
	
	缺点：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。

**4.常量存储**

	常量值通常直接存放在程序代码内部，这样做是安全的，因为他么永远不可能别改变。

**5.非RAM存储**

	流对象：对象转化成字节流发送给另外一台机器。
	
	持久化对象：对象存储在磁盘上，程序终止，仍可以保持自己的状态。这种存储技巧在于：把对象转化成可以存放在其他媒介的事物上，在需要时，可以恢复成常规的、基于RAM的对象。如：JDBC、Hibernate

#### 2.2.2 特例：基本类型

为什么要有基本类型?

	在程序设计过程中经常用到一系列类型，他们需要特殊对待。可以把它们想成”基本“类型。之所以特殊对待，是因为**new**将对象存储在”堆“中，所以用**new**创建一个对象——特别是小的，简单的变量，往往不是很好有效。因此对于这些类型，Java采取了与C/C++相同的方法，不用**new**来创建对象，而是创建一个并非是引用的”自动“变量。这个变量直接存储”值“，并**置于堆栈**中，因此更加高效。

| 基本类型 | 大小    | 最小值      | 最大值              | 包装器类型 |
| -------- | ------- | ----------- | ------------------- | ---------- |
| boolean  | —       | —           | —                   | Boolean    |
| char     | 16-bit  | $Unicode$ 0 | $Unicode$$2^{16}-1$ | Character  |
| byte     | 8-bits  | -128        | +127                | Byte       |
| short    | 16bits  | $-2^{15}$   | $+2^{15}-1$         | Short      |
| int      | 32bits  | $-2^{31}$   | $+2^{31}-1$         | Integer    |
| long     | 64bits  | $-2^{63}$   | $+2^{63}-1$         | Long       |
| float    | 32bits  | IEEE754     | IEEE754             | Float      |
| double   | 644bits | IEEE754     | IEEE754             | Double     |
| void     | —       | —           | —                   | Void       |

**所有数值类型都有正负号，所以不要去寻找无符号的数值类型。**

**boolean**

	类型所占用存储空间的大小没有明确指定，仅定义为能够取字面值**true 或 false**

**高精度数字**

	Java提供了两个用于高精度计算类：**BigInteger** 和 **BigDecimal** 。
	
	   **BigInteger**：支持任何精度的整型。
	
	   **BigDecimal**：支持任何精度的定点数，如：精确货币计算。

#### 2.2.3 Java中的数组

> C和C++使用数组很危险，因为C和C++中的数组就是内存块。如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，都会产生难以预料的错误。

	Java的主要目标之一是安全性，可确保数组被初始化，并且不能在它的范围之外被访问，这种范围检查是以每个数组上少量的内存开销及运行时的下标检查为代价的。由此换来是安全性和效率的提高，因此付出的代价是值得的。

### 2.3 永远不要销毁对象

	在大多数程序设计语言中，变量的生命周期的概念，占据了程序设计工作中非常重要的部分。变量需要存活多长时间？如果想要销毁对象，那么时候进行？变量生命周期的混乱往往会导致大量的程序bug。

#### 2.3.1 作用域

	大多数过程型语言都有作用域（scope）的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和Java中，作用域由花括号对的位置决定。

example：

```java
{
    int x = 12;
    // Only x avaliable
    {
        int q = 96;
        // Both x & q available
    }
    // Only x avaliable
    // q is "out of scope"
}
```

	在作用域里定义的变量值可能用于作用域结束之前。
	
	任何位于"//" 之后到行末的文字都是注释。
	
	缩排格式使Java代码更易于阅读。由于Java是一种自由格式（free-from）的语言，所以，空格，制表符，换行都不会影响程序的执行结果。

```java
{
    int x = 90;
    {
        int x = 900;
    }
}
```

	Java编程中不能够这么书写。
	
	编译器会报告变量x已经定义过，所以在C和C++里将一个较大的作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者任务这样做会导致程序混乱。

#### 2.3.2 对象作用域

	Java对象不具备和基本类型一样的生命周期，当用new创建一个Java对象时，它可以存活于作用域之外。

```java
{
    String s = new String("a string");
}// End of scope
```

	引用s在作用域终点就消失了。
	
	s指向的**String**对象仍继续占据内存空间。
	
	无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域范围。

问题：如果Java让对象继续存在，那么靠什么才能防止这些对象填满存储空间，进而阻塞你的程序？

	Java有个**垃圾回收器**，来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。

### 2.4 创建新的数据类型：类

如果一切都是对象，那么是什么决定了某个一类对象的外观与行为呢？是什么确定了对象的类型？
大多数面向对象程序设计语言习惯用关键字：**class**,**class**关键字之后紧跟新类型的名称。如下：

```java
class ATypeName { /* Class body goes here */ }
```

可以用**new**来创建这种类型的对象：

```java
ATypeName a = new ATypeName();
```

还是没有办法让它去做更多的事情，不能发送有任何意义的价值的信息。

#### 2.4.1 字段和方法

| 基本类型 | 默认值        |
| -------- | ------------- |
| boolean  | false         |
| char     | '\u000'(null) |
| byte     | (byte)0       |
| short    | (short)0      |
| int      | 0             |
| long     | 0L            |
| float    | 0.0f          |
| double   | 0.0d          |



	一旦定义了一个类，需要设置两种属性：**字段（有时被称为数据成员） 和 方法（有时被称为成员函数）**
	
	**字段：**可以是任何类型的对象，可以通过其引用进行通信；也可以是基本类型中的一种。

每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。如：

```java
class DataOnly{
    int i;
    double d;
    boolean b;
}
```

除了保存数据外没有别的用处，因为没有成员方法。

**基本成员默认值**

	若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。但是，这些初始值对你的程序来说，可能会是不正确的，甚至是不合法的。所以最好明确的对变量进行初始化。
	
	然而确保初始化的方法并不适用于“局部”变量（**即并非某个类的字段**）。因此，如果在某个方法定义中有：

```java
int x;
```

那么变量**x**得到的可能是任意值，而不会被自动初始化为0。所以在使用**x**前应该先对其赋值。如果你忘记了这么做，Java在编译时会返回一个错误，告诉你此时变量没有被初始化，这正是Java优于C++的地方。（许多C++编译器不会对未初始化变量给予警告，而Java则视为错误）。

### 2.5 方法、参数和返回值

	Java的方法决定了一个对象能够接收什么样的消息。方法的基本构成：名称、参数、返回值和方法体。如下：

```java
ReturnType methodName(/* Argument list */){
    /* Method body */
}
```

	返回类型描述的是在调用方法之后从方法返回的值。
	
	参数列表给出了要传给方法的信息的类型和名称。
	
	方法名和参数列表（它们合起来被称为“方法签名”）唯一地标识出某个方法。
	
	Java中的方法只能作为类的一个部分来创建。方法只能通过对象才能被调用，且这个对象必须能执行这个方法调用。
	
	如：假设有个方法f(),不带任何参数，返回类型是：int。如果有个对象a，可以通过对它调用f(),那么就可以这样写：

```java
int x = a.f();
```

	返回值的类型必须要与x的类型兼容。
	
	这种方法调用的行为通常称为：发送消息给对象。在上面的例子中，消息是f(),对象是a。面向对象的程序设计通常简单的归纳为“向对象发送消息”。

#### 2.5.1 参数列表

	方法的参数列表指定要传递给方法什么样的信息。如果参数被设为**String**类型，则必须传递一个**String**对象；否则，编译器将抛出错误。如下：

```java
int storage(String s){
    return s.length() * 2;
}
```

	此方法告诉你，需要多个字节才能容纳一个特定的**String**对象中的信息（**字符串中的每个字符的尺寸都是16位或2个字节，以此提供对Unicode字符集的支持**）。

**return**关键字：

  		1. 已经做完，离开此方法
  		2. 如果此方法产生了一个值，这个值要放在return语句后面

### 2.6构建一个Java程序

#### 2.6.1 名字可见性



#### 2.6.2 运用其他构件

**import**：import java.util.ArrayList

#### 2.6.3 static 关键字

	通常来说，当创建类时，就是在描述那个类的对象的外观和行为。除非用**new**创建那个类的对象，否则，实际上并未获得任何对象。执行**new**来创建对象时，数据存储空间才被分配，其方法才供外界调用。
	
	有两种情形用上述方法是无法解决的。
	
	第一种情形：只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。
	
	第二种情形：即使没有创建对象，也能调用这个方法。

通过**static**关键字可以满足这方面的需要。当声明一个事物是**static**，就意味着这个域或方法不会与包含他的那个类的任何对象实例关联在一起。所以即使从未创建某个类的任何对象，也可以调用其**static**方法或访问其**static**域。通常，你必须创建一个对象，并用它来访问数据或方法。

	有些面向对象语言采用类数据和类方法两个术语，代表那些数据和方法只是作为整个类，而不是类的某个特定对象而存在的。

```java
static StaticTest{
    static int i = 47;
}
```

创建两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i，如下：

```java
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```

在这里，st1.i 和st2.i指向同一个存储空间，因此他们具有相同的值47。

因为一个static字段对每个类来说都有一份存储空间，而非static字段则是对每个对象有一个存储空间。

**static**方法可以创建或使用其类型相同的被命名对象，因此，**static**方法常常拿来做“牧羊人”的角色，负责看护与其隶属同一类型的实例群。

### 2.7 你的第一个Java程序

编写一个完整的Java程序。

```java
// HelloDate.java
import java.util.*;

public class HelloDate {
    public static void main(String[] args){
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}
```

在每个文件开头，必须声明**import**语句，以便引入在文件代码中引入额外的类。

类的名字必须和文件的名字相同。

**public**关键字意指这是一个可由外部调用的方法。

**main()**方法的参数是一个**String**对象数组。**args**用来存储命令行参数。

代码：

```java
//: object/ShowProperties.java
public class ShowProperties{
    public static void main(String[] args){
        System.getProperties().list(System.out);
        System.out.println(System.getProperties("user.name"));
        System.out.println(System.getProperties("java.library.path"));
    }
}
```

#### 2.7.1 编译和运行

	要编译、运行这个程序以及本书中其他所有的程序，首先必须要一个Java开发环境。目前，有相当多的第三方厂商提供开发环境，这里使用Sun免费提供的JDK（Java Developer‘s Kit，Java开发人员工具包）开发环境。若使用其他的开发系统（**有IBM的jikes编译器也是一种常用编译器，他比Sun的javac快得多**）。

### 2.8 注释和嵌入式文档

	Java代码注释有两种风格。一种是传统的C语言风格的注释——C++也继承了这种风格。

```java
/*
 * This is a comment that
 * that continues
 * across lines
 */
```

	但请记住，进行编译时，/* 和 */之间所有东西都会被忽略，所以上述注释与下面这段注释并没有什么两样：

```java
/* This is a comment that 
continues across lines */
```

	第二种注释也源自C++。这种注释是“单行注释“，以一个”//“ 起头：

```java
// This is a one-line comment
```

#### 2.8.1 注释文档

	代码文档撰写最大的问题，大概就是对文档的维护了。如果文档与代码是分离的，那么在每次修改代码是，都需要修改相应的文档，这会成为一件相当乏味的事情。解决的方法似乎很简单：将代码同文档”链接“起来。为达到这个目的，最简单的方法是将所有东西都放在同一个文件内。
	
	javadoc便是用于提取注释的工具，他是JDK安装的一部分。它采用了Java编译器的某些技术，查找程序内的特殊注释标签。他不仅解析由这些标签标记的信息，也将毗邻注释的类名或方法名抽取出来，用最少的工作量，生成相当好的程序文档。

#### 2.8.2 语法

	所有Javadoc命令都只能在”/**“ 注释中出现，和通常一样，注释结束于 ” */“ 。使用javadoc的方式主要有两种：嵌入式HTML，或使用”文档标签“。独立文档标签是一些以”@“字符开头的命令，而行内文档标签则可以出现在javadoc注释中的任何地方，它们也是以”@“字符开头，但要括在花括号内。
	
	三种类型的注释文档：类，域和方法。
	
	javadoc只能为**public**和**protected**（受保护）成员进行文档注释。**private**（私有）和包内可访问成员的注释会被忽略掉。

#### 2.8.3 嵌入式HTML

	javadoc通过生成的HTML文档传送HTML命令，这使你能够充分利用HTML。当然，其主要目的还是为了对代码进行格式化，如下：

```java
//: object/Documention2.java
/**
 * <pre>
 * System.out.println(new Date);
 * </pre>
 /
```

	也可以像在其他web文档中那样运用HTML，对普通文本按照你自己所描述的进行格式化。

```java
//: object/Documentation3.java
/**
 * You can <em> even </em> inser a list
 * <ol>
 *  <li> Item one
 *	<li> Item two
 *	<li> Item three
 * </ol>
 */
```

	注意：在文档注释中，位于每一行开头的星号和前导空格都会被javadoc丢弃。javadoc会对所有内容重新格式化，使其与标准的文档外观一致。

#### 2.8.4 一些标签示例

	介绍一些可用于代码文档javadoc标签。查JDK文档的javadoc文档。

1. @see: 引用其他类

   **@see** classname

   **@see** fully-qualified-classname

   **@see** fully-qualified-classname#method-name

2. {@link packge.classname#method labe}

   该标签与@see相似，只是它用于行内，并且是用”label“作为超链接文本而不用”See Also”。

3. {@docRoot}

   该标签产生到文档根目录的相对路径，用于文档里树页面的显式超链接。

4. {@inheritDoc}

   该标签从当前这个类的最直接的基类中继承相关文档到当前文档的文档注释中。

5. @version

   该标签的格式如下：

   > @version version-infomation

其中，“**version-infomation**” 可以是任何你认为何时包含在版本说明中的重要信息。如果javadoc命令行使用了“**-version**” 标记，那么就从生成的HTML文档中特别提取出版本信息。

6. @author

   @author author-infomation

   其中，author-infomation一看便知是你的姓名，但是也可以包括电子邮件地址或者其他任何适宜的信息。如果javadoc命令行使用了-**author**标记，那么就从生成的HTML文档中特别提取作者信息。

   可以有多个标签，可出多个作者。

7. @since

   该标签允许拟制定程序代码最早使用的版本，可以在HTML Java文档中看到它被用来指定所有JDK版本的情况。

8. @param

   @param parameter-name description

其中，**parameter-name**是方法的参数列表中的标识，**description**是可延续数行的文本，终止于新的文档标签出现之前。可以使用任意多个这种标签。

6. @return

   @return **description**（说明返回值的含义，可以是多行。）

7. @throws

   “异常” ：某个方法调用失败而抛出的对象。在某些特殊方法可能会产生任意多个不同类型的异常，所有这些异常，所有这些异常都需要进行说明。标签如下：

   @throws **fully-qualified-class-name** 给出一个异常类的无歧义的名字，而该异常在别处定义。 **description**告诉你为什么此特殊类型的异常会在方法调用中出现

8. @deprecated

   此标签指出一些旧特性已由新特性所取代，建议用户不要再使用这些旧特性，

#### 2.8.5 文档注释示例

	示例：

```java
//: object/HelloDate.java
import java.util.*;
/** The first Thinking in Java example program
 * Display a string and today's date.
 * @author Bruce Ecke!
 * @author www.MindView.net
 * @version 4.0
 */
public class HelloDate{
    /** Entry point to class & application 
     * @param args array of string arguments
     * @throws exceptions No exceptions thrown
     */
    public static void main(String[] args){
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}
/* Output: (55% match)
 * Hello, it's
 * 2018-09-23 00:08:17
 *///:~
```

### 2.9 编码风格

 1. 类名首字母要大些；驼峰命名；

    ```java
    class AllTheColorsOfTheRainbow{}
    ```

## 第3章  操 作 符

	**在最底层，Java中的数据是通过使用操作符来操作的。**
	
	Java是建立在C++的基础上的。


	

#### 3.2 使用Java操作符

	操作符接受一个或多个参数，并生成一个新值。

**（+）加号**

**（-）减号** 

**（*）乘号**

**（/）除号**

**（=）赋值号**

	有些操作符可能会改变操作数自身的值，这被称为“副作用”。几乎所有的操作符都只能操作”基本类型“。例外的操作符是：”=“、”==“ 和 ”!=“，这些操作符能操作所有的对象，除此以外。**String**类支持”+“和”+=“。

#### 3.3 优先级

	当一个表达式存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。Java对计算顺序做了特别的规定。其中，最简单的规则就是先乘除后加减。程序员经常会忘记其他优先级规则，所以应该用括号明确规定计算顺序。例如：

```java
public class Precedence{
    public static void main(String[] args){
        int x = 1,y = 2, z = 3;
        int a = x + y - 2/2 + z;	//(1)
        int b = x + (y - 2)/(2 + z);//(2)
        System.out.println("a = " + a + " b = " + b);
    }
}
```

	**System.out.println()**语句中包含”+“操作符。在这种上下文环境中，”+”意味着“字符串链接”，并且如果必要，它还要执行“字符串转换”。

#### 3.4 赋值

	赋值使用“=”。它的意思就是：取右边的值（即右值），把它复制给左边（即左值）。

右值可以是常数，变量，表达式，但左值必须是一个明确的、已经命名的变量。必须有一个物理空间可以存储等号右边的值。如：

a = 9;

但是不能把任何东西赋值给常数，常数不能作为左值（如：9=a;）。

	对于基本数据类型的赋值是很简单的。基本类型存储了实际的数值，而并非指向一个对象的引用，直接将一个地方的内容赋值到了另一个地方。
	
	对于对象“赋值”，情况有所变化。对一个对象进行操作时，我们真正操作的是对对象的引用。如果“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着：对象使用c=d，那么c和d都指向原本只有d指向的那个对象。如下：

```java
import static net.mindView.util.Print.*;
class Tank{
    int level;
}
public class Assignment{
    public static void main(String[] args){
        Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1.level = 9;
        t2.level = 47;
        t1=t2;
    }
}
```

##### 3.4.1 方法调用中的别名问题

### 3.5 算术操作符

	Java的基本操作符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%，它从整数除法中产生余数）。整数除法会直接去掉结果的小数位，而不是四舍五入地圆整结果。
	
	Java也是用一种来自C和C++的简化符号，同时进行运行与赋值操作。

### 3.6 自动递增和递减

	递减操作符：--
	
	递增操作符：++
	
	前缀式：++a 等价于a = a + 1
	
	后缀式：a++ 




### 3.10 按位操作符

	按位操作符用来操作整数基本数据类型中的单个“比特”（bit）,即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。

	按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操作硬件，设置硬件寄存器内的二进制位。Java的设计初中时嵌入电视机机顶盒内，所以这种面向底层的操作仍被保留下来。但是，人们可能不会过多的用到位操作符。

	如果两个输入位都是1，则按位“与”操作符（**&**）生成一个输出位1，否则生成一个输出位0。如果两个输入位里只要有一个是1，则按位“或”操作符（**|**）生成一个输出位1；只有在两个输入位都是0。

| code  | desc                             |
| ----- | -------------------------------- |
| &     | 两个输入位都是1，生成一个输出位1 |
| \|    |                                  |
| *>>*  |                                  |
| <<    |                                  |
| *>>>* |                                  |
| *~*   |                                  |

### 3.11 移位操作符

	移位操作符的运算对象也是二进制的“位”。移位操作符只可用来处理整数类型（基本类型的一种）。

#### 3.15.1 截尾和舍入

	执行窄化转换时，必须注意截尾与舍入问题。

```java
public class CastingNumbers{
    public static void main(String[] args){
        double above = 0.7, below = 0.4;
        float fabove = 0.7f, fbelow = 0.4f;
        System.out.println("(int)above" + (int)above);
        System.out.println("(int)below" + (int)below);
        System.out.println("(Math.round())" + Math.round(above));
        System.out.println("(Math.round())" + Math.round(fabove));
    }
}
```

